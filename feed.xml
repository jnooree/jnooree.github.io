<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://blog.jnoor.ee/feed.xml" rel="self" type="application/atom+xml" /><link href="https://blog.jnoor.ee/" rel="alternate" type="text/html" hreflang="ko" /><updated>2023-07-03T19:58:27+09:00</updated><id>https://blog.jnoor.ee/feed.xml</id><title type="html">blog.jnoor.ee</title><subtitle>Yet another dev blog?</subtitle><author><name>Nuri Jung</name></author><entry><title type="html">Subprocess management</title><link href="https://blog.jnoor.ee/exploring%20the%20python%20standard%20library/2023/07/03/py-stdlib-subprocess.html" rel="alternate" type="text/html" title="Subprocess management" /><published>2023-07-03T19:34:59+09:00</published><updated>2023-07-03T19:57:52+09:00</updated><id>https://blog.jnoor.ee/exploring%20the%20python%20standard%20library/2023/07/03/py-stdlib-subprocess</id><content type="html" xml:base="https://blog.jnoor.ee/exploring%20the%20python%20standard%20library/2023/07/03/py-stdlib-subprocess.html"><![CDATA[<h2 id="package-index">Package index</h2>

<ul>
  <li><a href="https://docs.python.org/3/library/subprocess.html"><code class="language-plaintext highlighter-rouge">subprocess</code></a></li>
</ul>

<h2 id="ossystem-revisited"><code class="language-plaintext highlighter-rouge">os.system</code> revisited</h2>

<p>계산화학 연구를 하는 사람들이라면, RMSD를 계산해 주는
<a href="https://github.com/openbabel/openbabel">OpenBabel</a> 프로젝트의 <code class="language-plaintext highlighter-rouge">obrms</code> 프로그램을
한번쯤 다음과 같이 사용해 봤을 것입니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">os</span>
<span class="n">os</span><span class="p">.</span><span class="nf">system</span><span class="p">(</span><span class="sh">"</span><span class="s">obrms ref.mol2 test.mol2</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p>상황에 따라서는 파일명을 변수로 저장해 두는 경우도 있겠죠?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">os</span><span class="p">.</span><span class="nf">system</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">obrms </span><span class="si">{</span><span class="n">ref</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="n">test</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p>그런데 저 입력을 유저에게서 받았다고 생각해 봅시다. 그리고 <code class="language-plaintext highlighter-rouge">ref</code>와 <code class="language-plaintext highlighter-rouge">test</code> 변수가
어쩌다 보니 다음과 같이 정의되어 있다면 어떨까요?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ref</span> <span class="o">=</span> <span class="sh">"</span><span class="s">ref.mol2 test.mol2</span><span class="sh">"</span>
<span class="n">test</span> <span class="o">=</span> <span class="sh">"</span><span class="s">; rm -rf /home/jnooree</span><span class="sh">"</span>
</code></pre></div></div>

<p>축하합니다! rmsd 계산과 함께 <strong>홈 폴더가 통으로 날아갔습니다</strong>(…)</p>

<p>이쯤에서 shell에 익숙한 사람들은 quoting을 하면 되지 않느냐고 물어볼 텐데요,</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">os</span><span class="p">.</span><span class="nf">system</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">obrms </span><span class="sh">'</span><span class="si">{</span><span class="n">ref</span><span class="si">}</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="si">{</span><span class="n">test</span><span class="si">}</span><span class="sh">'"</span><span class="p">)</span>
</code></pre></div></div>

<p>네, 이번 경우는 위와 같은 코드에서 에러가 날 뿐, 홈 폴더를 지우진 않습니다.
그런데 정말 언제나 안전할까요?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ref</span> <span class="o">=</span> <span class="sh">"</span><span class="s">ref.mol2</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="s">test.mol2</span><span class="sh">"</span>
<span class="n">test</span> <span class="o">=</span> <span class="sh">"'</span><span class="s">; rm -rf /home/jnooree</span><span class="sh">'"</span>
</code></pre></div></div>

<p>어떤 똑똑한 해커가 위와 같이 변수를 입력했다면, 여전히 홈 폴더가 날아가는 것을
막을 수 없습니다. Quoting뿐만 아니라 어떤 식으로 방어하든, <strong>어딘가는 취약점이
있기 마련</strong>입니다. 그래서 <code class="language-plaintext highlighter-rouge">os.system</code>처럼 shell을 통해 프로그램을 실행하는
함수는 <strong>절대로</strong> 사용하지 말라고 권장하는 것입니다<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.</p>

<h2 id="subprocessrun"><code class="language-plaintext highlighter-rouge">subprocess.run()</code><sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></h2>

<p>그러면 어떻게 해야 할까요? Python 개발자들은 <code class="language-plaintext highlighter-rouge">subprocess.run()</code> 함수를 만들어
두었습니다. 이 함수는 기본적으로는 argument를 list로 받습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">subprocess</span>
<span class="n">subprocess</span><span class="p">.</span><span class="nf">run</span><span class="p">([</span><span class="sh">"</span><span class="s">obrms</span><span class="sh">"</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">test</span><span class="p">])</span>
</code></pre></div></div>

<p>내부적으로 저거 다시 join해서 shell로 실행하는 것 아니냐고요? 플랫폼에 따라
다르고, implementation detail이기 때문에 언제나 동일할 것이라고 장담은 못하지만,
Unix-like system에서는 fork 이후 아예 저 argument list를 <strong>그대로</strong> exec system
call로 넘겨버립니다(Python 3.10 기준). 취약점을 원천봉쇄하는 셈이죠.</p>

<p><code class="language-plaintext highlighter-rouge">subprocess.run()</code>은 단순히 안전하기만 한 것이 아니고, 여러 가지 유용한 기능을
추가로 제공하기도 합니다.</p>

<h3 id="출력-받아오기">출력 받아오기</h3>

<p><code class="language-plaintext highlighter-rouge">subprocess.run()</code>은 기본적으로 실행한 프로그램의 stdout과 stderr를 그대로
출력합니다. 그런데 상황에 따라 그 출력을 외부로 보내는 것이 아니라, 프로그램에서
사용하고 싶을 수도 있습니다. 이럴 때는 <code class="language-plaintext highlighter-rouge">subprocess.PIPE</code> 옵션을 사용합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">subprocess</span><span class="p">.</span><span class="nf">run</span><span class="p">([</span><span class="sh">"</span><span class="s">obrms</span><span class="sh">"</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">test</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">subprocess</span><span class="p">.</span><span class="n">PIPE</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">result</span><span class="p">.</span><span class="n">stdout</span>
<span class="sa">b</span><span class="sh">'</span><span class="s">RMSD ref:test 53.7078</span><span class="se">\n</span><span class="sh">'</span>
</code></pre></div></div>

<p>다만, 기본 설정은 binary로 출력을 받아오기 때문에(<code class="language-plaintext highlighter-rouge">bytes</code> object 반환),
<code class="language-plaintext highlighter-rouge">decode()</code>를 통해 <code class="language-plaintext highlighter-rouge">str</code>으로 변환해 주거나, <code class="language-plaintext highlighter-rouge">text=True</code> 옵션을 주어야<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>
일반적으로 사용하는 <code class="language-plaintext highlighter-rouge">str</code>으로 받아올 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">subprocess</span><span class="p">.</span><span class="nf">run</span><span class="p">([</span><span class="sh">"</span><span class="s">obrms</span><span class="sh">"</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">test</span><span class="p">],</span>
                            <span class="n">stdout</span><span class="o">=</span><span class="n">subprocess</span><span class="p">.</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">result</span><span class="p">.</span><span class="n">stdout</span>
<span class="sh">'</span><span class="s">RMSD ref:test 53.7078</span><span class="se">\n</span><span class="sh">'</span>
</code></pre></div></div>

<p>추가적인 장점으로, stdout과 stderr를 독립적으로 처리하기 때문에 앞에서 본 것과
같이 에러 메시지를 제외한 출력만 받아오거나(<code class="language-plaintext highlighter-rouge">stdout</code>만 이용), 둘 다 각각
받아오거나(<code class="language-plaintext highlighter-rouge">stdout</code>, <code class="language-plaintext highlighter-rouge">stderr</code> 이용), 또는 합쳐서 한번에 받아오는 등 다양한
방식으로 사용할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 출력만 받아오기 (stderr는 원래대로 출력)
</span><span class="n">result</span> <span class="o">=</span> <span class="n">subprocess</span><span class="p">.</span><span class="nf">run</span><span class="p">([</span><span class="sh">"</span><span class="s">obrms</span><span class="sh">"</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">test</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">subprocess</span><span class="p">.</span><span class="n">PIPE</span><span class="p">)</span>
<span class="c1"># 각각 받아오기
</span><span class="n">result</span> <span class="o">=</span> <span class="n">subprocess</span><span class="p">.</span><span class="nf">run</span><span class="p">([</span><span class="sh">"</span><span class="s">obrms</span><span class="sh">"</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">test</span><span class="p">],</span>
                        <span class="n">stdout</span><span class="o">=</span><span class="n">subprocess</span><span class="p">.</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">subprocess</span><span class="p">.</span><span class="n">PIPE</span><span class="p">)</span>
<span class="c1"># 합쳐서 받아오기
</span><span class="n">result</span> <span class="o">=</span> <span class="n">subprocess</span><span class="p">.</span><span class="nf">run</span><span class="p">([</span><span class="sh">"</span><span class="s">obrms</span><span class="sh">"</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">test</span><span class="p">],</span>
                        <span class="n">stdout</span><span class="o">=</span><span class="n">subprocess</span><span class="p">.</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">subprocess</span><span class="p">.</span><span class="n">STDOUT</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="sending-input-to-child">Sending input to child</h3>

<p><code class="language-plaintext highlighter-rouge">subprocess.run()</code>을 이용하면 실행하는 프로그램의 stdin으로 직접 데이터를
보낼 수도 있습니다. 이때는 <code class="language-plaintext highlighter-rouge">input</code> 옵션을 사용합니다. 이 경우에도 기본적으로는
<code class="language-plaintext highlighter-rouge">bytes</code> object를 받아들이기 때문에, <code class="language-plaintext highlighter-rouge">text=True</code> 옵션을 주거나 <code class="language-plaintext highlighter-rouge">encode()</code>해
주어야 합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">subprocess</span><span class="p">.</span><span class="nf">run</span><span class="p">([</span><span class="sh">"</span><span class="s">grep</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">a</span><span class="sh">"</span><span class="p">],</span> <span class="nb">input</span><span class="o">=</span><span class="sa">b</span><span class="sh">"</span><span class="s">abc</span><span class="se">\n</span><span class="s">def</span><span class="se">\n</span><span class="s">ghi</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span>
                            <span class="n">stdout</span><span class="o">=</span><span class="n">subprocess</span><span class="p">.</span><span class="n">PIPE</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">result</span><span class="p">.</span><span class="n">stdout</span>
<span class="sa">b</span><span class="sh">'</span><span class="s">abc</span><span class="se">\n</span><span class="sh">'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">subprocess</span><span class="p">.</span><span class="nf">run</span><span class="p">([</span><span class="sh">"</span><span class="s">grep</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">a</span><span class="sh">"</span><span class="p">],</span> <span class="nb">input</span><span class="o">=</span><span class="sh">"</span><span class="s">abc</span><span class="se">\n</span><span class="s">def</span><span class="se">\n</span><span class="s">ghi</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span>
                            <span class="n">stdout</span><span class="o">=</span><span class="n">subprocess</span><span class="p">.</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">result</span><span class="p">.</span><span class="n">stdout</span>
<span class="sh">'</span><span class="s">abc</span><span class="se">\n</span><span class="sh">'</span>
</code></pre></div></div>

<p>또는 <code class="language-plaintext highlighter-rouge">subprocess.PIPE</code>를 사용하여 파일 등으로부터 데이터를 넘겨줄 수도 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="sh">"</span><span class="s">input.txt</span><span class="sh">"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="p">...</span>     <span class="n">result</span> <span class="o">=</span> <span class="n">subprocess</span><span class="p">.</span><span class="nf">run</span><span class="p">([</span><span class="sh">"</span><span class="s">grep</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">a</span><span class="sh">"</span><span class="p">],</span>
<span class="p">...</span>                             <span class="n">stdin</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">subprocess</span><span class="p">.</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">result</span><span class="p">.</span><span class="n">stdout</span>
<span class="sh">'</span><span class="s">abc</span><span class="se">\n</span><span class="sh">'</span>
</code></pre></div></div>

<p>많은 경우, 임시파일을 거쳐 프로그램에 입/출력하는 구현은 사실 이런 방식으로
대체하는 것이 훨씬 효율적이고 편리합니다.</p>

<h3 id="error-handling">Error handling</h3>

<p><code class="language-plaintext highlighter-rouge">os.system()</code>은 실행한 프로그램의 종료 코드를 반환하고, <code class="language-plaintext highlighter-rouge">subprocess.run()</code>도
기본적으로는 동일하게 종료 코드를 반환합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">subprocess</span><span class="p">.</span><span class="nf">run</span><span class="p">([</span><span class="sh">"</span><span class="s">rm</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">/</span><span class="sh">"</span><span class="p">])</span>  <span class="c1"># No error?
</span><span class="n">rm</span><span class="p">:</span> <span class="n">cannot</span> <span class="n">remove</span> <span class="sh">'</span><span class="s">/</span><span class="sh">'</span><span class="p">:</span> <span class="n">Is</span> <span class="n">a</span> <span class="n">directory</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ret</span><span class="p">.</span><span class="n">returncode</span>
<span class="mi">1</span>
</code></pre></div></div>

<p>하지만 Python에서 우리는 보통 <code class="language-plaintext highlighter-rouge">try-except</code> 구문을 통해 에러를 처리합니다.
<code class="language-plaintext highlighter-rouge">subprocess.run()</code>을 사용할 때는 <code class="language-plaintext highlighter-rouge">check=True</code> 옵션을 주면, 종료 코드가 0이 아닌
경우 exception을 발생시키도록 할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">subprocess</span><span class="p">.</span><span class="nf">run</span><span class="p">([</span><span class="sh">"</span><span class="s">rm</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">/</span><span class="sh">"</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">rm</span><span class="p">:</span> <span class="n">cannot</span> <span class="n">remove</span> <span class="sh">'</span><span class="s">/</span><span class="sh">'</span><span class="p">:</span> <span class="n">Is</span> <span class="n">a</span> <span class="n">directory</span>
<span class="nc">Traceback </span><span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
    <span class="bp">...</span>
<span class="n">subprocess</span><span class="p">.</span><span class="n">CalledProcessError</span><span class="p">:</span> <span class="n">Command</span> <span class="sh">'</span><span class="s">[</span><span class="sh">'</span><span class="n">rm</span><span class="sh">'</span><span class="s">, </span><span class="sh">'</span><span class="o">/</span><span class="sh">'</span><span class="s">]</span><span class="sh">'</span> <span class="n">returned</span> <span class="n">non</span><span class="o">-</span><span class="n">zero</span> <span class="nb">exit</span> <span class="n">status</span> <span class="mf">1.</span>
</code></pre></div></div>

<p>이때 발생하는 exception은 <code class="language-plaintext highlighter-rouge">subprocess.CalledProcessError</code>입니다.</p>

<h3 id="timeout">Timeout</h3>

<p>상황에 따라, 프로그램이 일정 시간 이상 걸리면 종료시키고 싶을 수도 있습니다.
<code class="language-plaintext highlighter-rouge">subprocess.run()</code>은 <code class="language-plaintext highlighter-rouge">timeout</code> 옵션을 통해 이를 지원합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">subprocess</span><span class="p">.</span><span class="nf">run</span><span class="p">([</span><span class="sh">"</span><span class="s">sleep</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">10</span><span class="sh">"</span><span class="p">],</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="nc">Traceback </span><span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
    <span class="bp">...</span>
<span class="n">subprocess</span><span class="p">.</span><span class="n">TimeoutExpired</span><span class="p">:</span> <span class="n">Command</span> <span class="sh">'</span><span class="s">[</span><span class="sh">'</span><span class="n">sleep</span><span class="sh">'</span><span class="s">, </span><span class="sh">'</span><span class="mi">10</span><span class="sh">'</span><span class="s">]</span><span class="sh">'</span> <span class="n">timed</span> <span class="n">out</span> <span class="n">after</span> <span class="mi">5</span> <span class="n">seconds</span>
</code></pre></div></div>

<p>이때 발생하는 exception은 <code class="language-plaintext highlighter-rouge">subprocess.TimeoutExpired</code>입니다.</p>

<h3 id="still-using-shell">Still using shell</h3>

<p><code class="language-plaintext highlighter-rouge">subprocess.run()</code>은 기본적으로 shell을 사용하지 않습니다. 하지만 상황에 따라
globbing, redirection 등 shell에서 제공하는 부가기능을 사용하고 싶을 수도
있습니다. 이때는 <code class="language-plaintext highlighter-rouge">shell=True</code> 옵션을 주고, <code class="language-plaintext highlighter-rouge">os.system()</code>과 유사하게 <code class="language-plaintext highlighter-rouge">str</code>으로
명령어를 넘겨주면 됩니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">subprocess</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="sh">"</span><span class="s">echo *.py</span><span class="sh">"</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">main</span><span class="p">.</span><span class="n">py</span>
</code></pre></div></div>

<p>하지만 대부분의 경우에는 Python 내부적으로 제공하는 기능으로 충분하기 때문에,
<code class="language-plaintext highlighter-rouge">shell=True</code> 옵션을 사용하는 것은 권장하지 않습니다. (위의 예제는 <code class="language-plaintext highlighter-rouge">glob</code> 모듈
또는 <code class="language-plaintext highlighter-rouge">pathlib</code> 모듈을 사용하여 대체할 수 있습니다.)</p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>비슷한 느낌의 공격으로 <a href="https://en.wikipedia.org/wiki/SQL_injection">SQL injection</a>이 있습니다. 데이터베이스에 대한 공격인데, 이와 더불어 여러 문제점 때문에 user에게 받은 입력을 곧바로 sql문으로 실행하는 것은 금기시됩니다. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>Since Python 3.5 (Sep 2015) <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>Since Python 3.7 (Jun 2018) <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Nuri Jung</name></author><category term="Exploring the Python Standard Library" /><category term="dev" /><category term="python" /><summary type="html"><![CDATA[Package index]]></summary></entry><entry><title type="html">Collections</title><link href="https://blog.jnoor.ee/exploring%20the%20python%20standard%20library/2022/08/23/py-stdlib-collections.html" rel="alternate" type="text/html" title="Collections" /><published>2022-08-23T14:35:05+09:00</published><updated>2022-08-23T15:56:28+09:00</updated><id>https://blog.jnoor.ee/exploring%20the%20python%20standard%20library/2022/08/23/py-stdlib-collections</id><content type="html" xml:base="https://blog.jnoor.ee/exploring%20the%20python%20standard%20library/2022/08/23/py-stdlib-collections.html"><![CDATA[<h2 id="package-index">Package index</h2>

<ul>
  <li><a href="https://docs.python.org/3/library/collections.html"><code class="language-plaintext highlighter-rouge">collections</code></a></li>
</ul>

<h2 id="defaultdict"><code class="language-plaintext highlighter-rouge">defaultdict</code></h2>

<h3 id="a-common-workflow">A common workflow</h3>

<p>어떤 리스트를 특정 조건을 만족하는 더 작은 리스트로 나누는 작업은 상당히 빈번하게 일어납니다. 대개는 아래와 같이 작성하게 되죠.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">l</span> <span class="o">=</span> <span class="p">[(</span><span class="sh">"</span><span class="s">yellow</span><span class="sh">"</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="sh">"</span><span class="s">blue</span><span class="sh">"</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="sh">"</span><span class="s">yellow</span><span class="sh">"</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">...]</span>
<span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">color</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">color</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
        <span class="n">d</span><span class="p">[</span><span class="n">color</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">d</span><span class="p">[</span><span class="n">color</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="a-better-workflow">A better workflow</h3>

<p>그러나 위와 같은 방식은 비교적 덜 자주 일어나는 “새로운 key를 만나는 경우”를 위해 모든 원소에 대해 조건문을 실행한다는 단점이 있습니다. 이를 개선하는 방법은 try-except 문을 통해 <code class="language-plaintext highlighter-rouge">KeyError</code>를 <a href="https://docs.python.org/3.5/glossary.html#term-eafp">처리하는 것입니다</a>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">l</span> <span class="o">=</span> <span class="p">[(</span><span class="sh">"</span><span class="s">yellow</span><span class="sh">"</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="sh">"</span><span class="s">blue</span><span class="sh">"</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="sh">"</span><span class="s">yellow</span><span class="sh">"</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">...]</span>
<span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">color</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">d</span><span class="p">[</span><span class="n">color</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">except</span> <span class="nb">KeyError</span><span class="p">:</span>
        <span class="n">d</span><span class="p">[</span><span class="n">color</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="the-best-workflow">The best workflow</h3>

<p>그러나 가장 좋은 방법은 애초에 python 코드를 적게 작성하는 것입니다. 이를 위해 <code class="language-plaintext highlighter-rouge">defaultdict</code>를 <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict">사용할 수 있습니다</a>. 코드가 전체적으로 훨씬 깔끔해지고 가독성이 높아지는 것을 볼 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="n">l</span> <span class="o">=</span> <span class="p">[(</span><span class="sh">"</span><span class="s">yellow</span><span class="sh">"</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="sh">"</span><span class="s">blue</span><span class="sh">"</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="sh">"</span><span class="s">yellow</span><span class="sh">"</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">...]</span>
<span class="n">d</span> <span class="o">=</span> <span class="nf">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
<span class="k">for</span> <span class="n">color</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
    <span class="n">d</span><span class="p">[</span><span class="n">color</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">defaultdict</code>는 <code class="language-plaintext highlighter-rouge">dict</code>의 subclass이기 때문에 <code class="language-plaintext highlighter-rouge">dict</code>의 모든 메서드를 사용할 수 있습니다.</p>

<h3 id="benchmarks">Benchmarks</h3>

<p>위의 세 가지 방법의 속도를 비교해보았습니다. <code class="language-plaintext highlighter-rouge">defaultdict</code>를 이용하면 최대 10%정도 속도 향상이 있는데, 이는 <code class="language-plaintext highlighter-rouge">defaultdict</code>는 <a href="https://github.com/python/cpython/blob/1499d73b3e02878850c007fa7298bb62f6c5a9a1/Modules/_collectionsmodule.c#L1955-L2269">C로 구현되어 있기 때문입니다</a>. 코드가 깔끔해지는 것 외에도 속도 향상까지 얻을 수 있는 셈이죠.</p>

<figure class="image">
	<img src="/assets/images/posts/exploring-python-stdlib/defaultdict-bench.png" alt="Tested on M1 mac mini (2020), Python 3.10.5" /><figcaption>Tested on M1 mac mini (2020), Python 3.10.5</figcaption></figure>

<h2 id="counter"><code class="language-plaintext highlighter-rouge">Counter</code></h2>

<h3 id="counting-occurrences">Counting occurrences</h3>

<p>또 다른 자주 있는 작업은 리스트 원소의 빈도수를 세는 것입니다. 보통은 이렇게 작성하는 경우가 많습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="sh">"</span><span class="s">foo</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">bar</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">bar</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">baz</span><span class="sh">"</span><span class="p">,</span> <span class="p">...]</span>
<span class="n">c</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
        <span class="n">c</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">c</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div></div>

<h3 id="oh-defaultdict-my-defaultdict">Oh, <code class="language-plaintext highlighter-rouge">defaultdict</code>, my <code class="language-plaintext highlighter-rouge">defaultdict</code></h3>

<p>물론 앞서 소개했던 <code class="language-plaintext highlighter-rouge">defaultdict</code>를 이용하면 더 깔끔하게 작성할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="sh">"</span><span class="s">foo</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">bar</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">bar</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">baz</span><span class="sh">"</span><span class="p">,</span> <span class="p">...]</span>
<span class="n">c</span> <span class="o">=</span> <span class="nf">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
    <span class="n">c</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div></div>

<h3 id="use-the-right-tool">Use <em>the</em> right tool</h3>

<p>하지만 이런 작업은 워낙 자주 사용되어서 모든 것을 아예 자동으로 처리해주는 <code class="language-plaintext highlighter-rouge">Counter</code>가 <a href="https://docs.python.org/3/library/collections.html#collections.Counter">준비되어 있습니다</a>.<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">Counter</span>

<span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="sh">"</span><span class="s">foo</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">bar</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">bar</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">baz</span><span class="sh">"</span><span class="p">,</span> <span class="p">...]</span>
<span class="n">c</span> <span class="o">=</span> <span class="nc">Counter</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Counter</code> 역시 <code class="language-plaintext highlighter-rouge">dict</code>의 subclass이기 때문에 <code class="language-plaintext highlighter-rouge">dict</code>의 모든 method를 사용할 수 있습니다. 또한 <code class="language-plaintext highlighter-rouge">Counter</code>는 <code class="language-plaintext highlighter-rouge">most_common</code> 등의 유용한 method를 제공한다는 추가적인 장점도 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="p">.</span><span class="nf">most_common</span><span class="p">()</span>
<span class="p">[(</span><span class="sh">'</span><span class="s">bar</span><span class="sh">'</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="sh">'</span><span class="s">foo</span><span class="sh">'</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="sh">'</span><span class="s">baz</span><span class="sh">'</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">...]</span>
</code></pre></div></div>

<h3 id="benchmarks-1">Benchmarks</h3>

<p>위의 세 방법과 더불어 exception으로 처리한 방법까지 총 네 가지에 대해 속도를 비교해 보았습니다.</p>

<figure class="image">
	<img src="/assets/images/posts/exploring-python-stdlib/counter-bench.png" alt="Tested on M1 mac mini (2020), Python 3.10.5" /><figcaption>Tested on M1 mac mini (2020), Python 3.10.5</figcaption></figure>

<p>지금까지 중 가장 드라마틱한 차이로, 2배 이상 빨라지는 것을 확인할 수 있습니다. 이것 역시 <code class="language-plaintext highlighter-rouge">Counter</code>의 핵심 부분이 <a href="https://github.com/python/cpython/blob/d6259c58cbb48b8f3fbd70047f004ea19fe91e86/Modules/_collectionsmodule.c#L2271-L2388">C로 구현되어 있기 때문이죠</a>.</p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Available since Python 3.1 (Jun 2009). <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Nuri Jung</name></author><category term="Exploring the Python Standard Library" /><category term="dev" /><category term="python" /><summary type="html"><![CDATA[Package index]]></summary></entry><entry><title type="html">Manipulating paths in Python</title><link href="https://blog.jnoor.ee/exploring%20the%20python%20standard%20library/2022/07/19/py-stdlib-paths.html" rel="alternate" type="text/html" title="Manipulating paths in Python" /><published>2022-07-19T20:44:20+09:00</published><updated>2022-07-19T22:56:45+09:00</updated><id>https://blog.jnoor.ee/exploring%20the%20python%20standard%20library/2022/07/19/py-stdlib-paths</id><content type="html" xml:base="https://blog.jnoor.ee/exploring%20the%20python%20standard%20library/2022/07/19/py-stdlib-paths.html"><![CDATA[<h2 id="package-index">Package index</h2>

<ul>
  <li><a href="https://docs.python.org/3/library/pathlib.html"><code class="language-plaintext highlighter-rouge">pathlib</code></a><sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></li>
  <li><a href="https://docs.python.org/3/library/shutil.html"><code class="language-plaintext highlighter-rouge">shutil</code></a></li>
  <li><a href="https://docs.python.org/3/library/tempfile.html"><code class="language-plaintext highlighter-rouge">tempfile</code></a></li>
</ul>

<h2 id="object-oriented-filesystem-paths">Object-oriented filesystem paths</h2>

<p>이 글을 읽고 나면, 여러분이 작성하시는 코드는 대부분 이 줄을 포함하게 될 겁니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
</code></pre></div></div>

<h3 id="what-is-pathlib">What is <code class="language-plaintext highlighter-rouge">pathlib</code>?</h3>

<p>Python 개발자들이 붙인 부제가 아주 잘 설명하고 있듯이, <code class="language-plaintext highlighter-rouge">pathlib</code>은 object-oriented filesystem path(<code class="language-plaintext highlighter-rouge">Path</code>)를 제공합니다. 다른 말로 하면, 이 라이브러리를 사용하면 파일 및 경로를 별도의 object로 다룰 수 있게 됩니다.</p>

<h3 id="path-object-initialization">Path object initialization</h3>

<p>모든 object는 어떤 식으로든지 생성되어야 합니다. <code class="language-plaintext highlighter-rouge">Path</code> object를 생성하는 방법은 여러 가지가 있습니다만, 자주 사용되는 방법은 다음과 같습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># p points to any/path/you/want
</span><span class="n">p</span> <span class="o">=</span> <span class="nc">Path</span><span class="p">(</span><span class="sh">"</span><span class="s">any/path/you/want</span><span class="sh">"</span><span class="p">)</span>
<span class="c1"># Also works with segments
</span><span class="n">p</span> <span class="o">=</span> <span class="nc">Path</span><span class="p">(</span><span class="sh">"</span><span class="s">any</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">path</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">you</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">want</span><span class="sh">"</span><span class="p">)</span>
<span class="c1"># Current working directory
</span><span class="n">p</span> <span class="o">=</span> <span class="n">Path</span><span class="p">.</span><span class="nf">cwd</span><span class="p">()</span>
<span class="c1"># Home directory; since 3.5 (Sep 2015)
</span><span class="n">p</span> <span class="o">=</span> <span class="n">Path</span><span class="p">.</span><span class="nf">home</span><span class="p">()</span>
<span class="c1"># Home directory of user jnooree; since 3.5 (Sep 2015)
</span><span class="n">p</span> <span class="o">=</span> <span class="n">Path</span><span class="p">.</span><span class="nf">home</span><span class="p">(</span><span class="sh">"</span><span class="s">~jnooree</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="properties-of-path-object">Properties of Path object</h3>

<p>대부분의 object는 property도 가지죠. <code class="language-plaintext highlighter-rouge">Path</code> object의 경우에는 다음과 같은 유용한 property를 가집니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="nc">Path</span><span class="p">(</span><span class="sh">"</span><span class="s">any</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">path</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">you</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">want</span><span class="sh">"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span>
<span class="nc">PosixPath</span><span class="p">(</span><span class="sh">'</span><span class="s">any/path/you/want</span><span class="sh">'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span><span class="p">.</span><span class="n">parts</span>
<span class="p">[</span><span class="sh">'</span><span class="s">any</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">path</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">you</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">want</span><span class="sh">'</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span><span class="p">.</span><span class="n">parent</span>
<span class="nc">PosixPath</span><span class="p">(</span><span class="sh">'</span><span class="s">any/path/you</span><span class="sh">'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span><span class="p">.</span><span class="n">parents</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="nc">PosixPath</span><span class="p">(</span><span class="sh">'</span><span class="s">any/path</span><span class="sh">'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span><span class="p">.</span><span class="n">parents</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>  <span class="c1"># Since 3.10 (Oct 2021)
</span><span class="p">(</span><span class="nc">PosixPath</span><span class="p">(</span><span class="sh">'</span><span class="s">any</span><span class="sh">'</span><span class="p">),</span> <span class="nc">PosixPath</span><span class="p">(</span><span class="sh">'</span><span class="s">.</span><span class="sh">'</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="nc">Path</span><span class="p">(</span><span class="sh">"</span><span class="s">foo/bar.dir</span><span class="sh">"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span><span class="p">.</span><span class="n">name</span>
<span class="sh">'</span><span class="s">bar.dir</span><span class="sh">'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span><span class="p">.</span><span class="n">stem</span>
<span class="sh">'</span><span class="s">bar</span><span class="sh">'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span><span class="p">.</span><span class="n">suffix</span>
<span class="sh">'</span><span class="s">.dir</span><span class="sh">'</span>
</code></pre></div></div>

<p>이들 중에서는 특히 <code class="language-plaintext highlighter-rouge">Path.parent</code>, <code class="language-plaintext highlighter-rouge">Path.name</code>, <code class="language-plaintext highlighter-rouge">Path.stem</code> 등이 굉장히 자주, 또 유용하게 사용됩니다.</p>

<h3 id="path-manipulations">Path manipulations</h3>

<p>이제 <code class="language-plaintext highlighter-rouge">Path</code> object를 어떻게 다루는지도 살펴봅시다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="nc">Path</span><span class="p">(</span><span class="sh">"</span><span class="s">foo/bar.dir</span><span class="sh">"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span> <span class="o">/</span> <span class="sh">"</span><span class="s">baz.txt</span><span class="sh">"</span>
<span class="nc">PosixPath</span><span class="p">(</span><span class="sh">'</span><span class="s">foo/bar.dir/baz.txt</span><span class="sh">'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span><span class="p">.</span><span class="nf">joinpath</span><span class="p">(</span><span class="sh">"</span><span class="s">baz</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">qux.txt</span><span class="sh">"</span><span class="p">)</span>
<span class="nc">PosixPath</span><span class="p">(</span><span class="sh">'</span><span class="s">foo/bar.dir/baz/qux.txt</span><span class="sh">'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span><span class="p">.</span><span class="nf">with_name</span><span class="p">(</span><span class="sh">"</span><span class="s">quux</span><span class="sh">"</span><span class="p">)</span>
<span class="nc">PosixPath</span><span class="p">(</span><span class="sh">'</span><span class="s">foo/quux</span><span class="sh">'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span><span class="p">.</span><span class="nf">with_stem</span><span class="p">(</span><span class="sh">"</span><span class="s">quz</span><span class="sh">"</span><span class="p">)</span>  <span class="c1"># Since 3.9 (Oct 2020)
</span><span class="nc">PosixPath</span><span class="p">(</span><span class="sh">'</span><span class="s">foo/quz.dir</span><span class="sh">'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span><span class="p">.</span><span class="nf">with_suffix</span><span class="p">(</span><span class="sh">"</span><span class="s">.d</span><span class="sh">"</span><span class="p">)</span>
<span class="nc">PosixPath</span><span class="p">(</span><span class="sh">'</span><span class="s">foo/bar.d</span><span class="sh">'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span><span class="p">.</span><span class="nf">resolve</span><span class="p">()</span>  <span class="c1"># Make path absolute
</span><span class="nc">PosixPath</span><span class="p">(</span><span class="sh">'</span><span class="s">/home/jnooree/foo/bar.dir</span><span class="sh">'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span><span class="p">.</span><span class="nf">resolve</span><span class="p">(</span><span class="n">strict</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c1"># Since 3.6 (Dec 2016)
</span><span class="nb">FileNotFoundError</span><span class="p">:</span> <span class="p">[</span><span class="n">Errno</span> <span class="mi">2</span><span class="p">]</span> <span class="n">No</span> <span class="n">such</span> <span class="nb">file</span> <span class="ow">or</span> <span class="n">directory</span><span class="p">:</span> <span class="bp">...</span>
</code></pre></div></div>

<p>이것만으로도 대부분의 경로와 관련된 상황을 전부 커버 가능합니다.</p>

<p>특히 <code class="language-plaintext highlighter-rouge">Path.with_suffix()</code> method는 같은 이름의 다른 형식 파일을 생성할 때 유용한데요, computational chemistry 쪽에서는 파일 형식 변환을 자주 하기 때문에 굉장히 많이 쓰입니다. Python 3.9에 추가된 <code class="language-plaintext highlighter-rouge">Path.with_stem()</code>는 반대로 파일 형식을 유지한 채로 전/후처리를 거친 파일의 이름을 약간만 바꿔주고 싶을 때 유용합니다. 예를 들면 다음과 같은 식으로요.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sdf</span> <span class="o">=</span> <span class="nc">Path</span><span class="p">(</span><span class="sh">"</span><span class="s">foo.sdf</span><span class="sh">"</span><span class="p">)</span>
<span class="n">mol2</span> <span class="o">=</span> <span class="n">sdf</span><span class="p">.</span><span class="nf">with_suffix</span><span class="p">(</span><span class="sh">"</span><span class="s">.mol2</span><span class="sh">"</span><span class="p">)</span>  <span class="c1"># foo.mol2
</span><span class="n">mol2_3d</span> <span class="o">=</span> <span class="n">mol2</span><span class="p">.</span><span class="nf">with_stem</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">mol2</span><span class="p">.</span><span class="n">stem</span><span class="si">}</span><span class="s">_3d</span><span class="sh">"</span><span class="p">)</span>  <span class="c1"># foo_3d.mol2
</span></code></pre></div></div>

<h3 id="querying-metadata">Querying metadata</h3>

<p>파일이 실제로 디스크에 존재하는지 <del>폰파일은 아닌지</del> 확인하는 등, 해당 경로의 metadata를 확인하는 method도 유용하게 사용 가능합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p</span> <span class="o">=</span> <span class="nc">Path</span><span class="p">(</span><span class="sh">"</span><span class="s">foo/bar.txt</span><span class="sh">"</span><span class="p">)</span>
<span class="c1"># Check if the path exists
</span><span class="n">p</span><span class="p">.</span><span class="nf">exists</span><span class="p">()</span>
<span class="c1"># Check if the path exists and is a directory (or a symlink to a directory)
</span><span class="n">p</span><span class="p">.</span><span class="nf">is_dir</span><span class="p">()</span>
<span class="c1"># Check if the path exists and is a file (or a symlink to a file)
</span><span class="n">p</span><span class="p">.</span><span class="nf">is_file</span><span class="p">()</span>
<span class="c1"># Check if the path is an absolute path
</span><span class="n">p</span><span class="p">.</span><span class="nf">is_absolute</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="directory-related-operations">Directory related operations</h3>

<p>Bash나 zsh 등의 shell에서는 어떤 디렉토리 내부의 모든 파일에 대해 무언가를 실행하는 것이 용이하지만, Python에서 비슷한 방식으로 작업하기는 그리 간단하지 않습니다. <code class="language-plaintext highlighter-rouge">pathlib</code>이 여기에서도 구원투수로 등판합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">d</span> <span class="o">=</span> <span class="nc">Path</span><span class="p">(</span><span class="sh">"</span><span class="s">foo/bar</span><span class="sh">"</span><span class="p">)</span>
<span class="c1"># Equivalent to mkdir foo/bar
</span><span class="n">d</span><span class="p">.</span><span class="nf">mkdir</span><span class="p">()</span>
<span class="c1"># Equivalent to mkdir -p foo/bar; since 3.5 (Sep 2015)
</span><span class="n">d</span><span class="p">.</span><span class="nf">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c1"># Iterator of directory contents
</span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">d</span><span class="p">.</span><span class="nf">iterdir</span><span class="p">():</span> <span class="bp">...</span>
<span class="c1"># Iterator of directory contents, matching a glob pattern
</span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">d</span><span class="p">.</span><span class="nf">glob</span><span class="p">(</span><span class="sh">"</span><span class="s">*.txt</span><span class="sh">"</span><span class="p">):</span> <span class="bp">...</span>
<span class="c1"># Recursive globbing is also supported
</span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">d</span><span class="p">.</span><span class="nf">glob</span><span class="p">(</span><span class="sh">"</span><span class="s">**/*.txt</span><span class="sh">"</span><span class="p">):</span> <span class="bp">...</span>
</code></pre></div></div>

<h3 id="file-related-operations">File related operations</h3>

<p>디렉토리가 있으면 파일도 있어야겠죠?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">text</span> <span class="o">=</span> <span class="nc">Path</span><span class="p">(</span><span class="sh">"</span><span class="s">foo/bar.txt</span><span class="sh">"</span><span class="p">)</span>
<span class="c1"># Equivalent to open(text)
</span><span class="k">with</span> <span class="n">text</span><span class="p">.</span><span class="nf">open</span><span class="p">()</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="bp">...</span>

<span class="c1"># Whole file contents as a string; since 3.5 (Sep 2015)
</span><span class="n">content</span> <span class="o">=</span> <span class="n">text</span><span class="p">.</span><span class="nf">read_text</span><span class="p">()</span>
<span class="c1"># Write a string to a file; since 3.5 (Sep 2015)
</span><span class="n">text</span><span class="p">.</span><span class="nf">write_text</span><span class="p">(</span><span class="sh">"</span><span class="s">Hello, world!</span><span class="se">\n</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p>물론 첫 번째 예시에서 <code class="language-plaintext highlighter-rouge">Path.open()</code> method 대신 기존과 동일하게 built-in <code class="language-plaintext highlighter-rouge">open()</code> 함수를 사용해도 됩니다<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>. 두번째 예시의 경우 간단한 파일 입출력에서 아주 유용하게 사용 가능합니다. 단, <code class="language-plaintext highlighter-rouge">Path.write_text()</code>는 항상 write mode로 파일을 열기 때문에 동일한 파일에 여러 번 호출하면 <strong>안 됩니다</strong>. <code class="language-plaintext highlighter-rouge">Path.read_text()</code>는 매우 큰 파일에 대해 실행할 경우 메모리 문제가 발생할 수 있다는 것도 기억해 두면 좋습니다.</p>

<h3 id="moving-files-around">Moving files around</h3>

<p>또 shell에서는 쉽지만 Python에서 어려운 작업이 파일/디렉토리를 이동하거나 삭제하는 것인데요, 일부 작업은 <code class="language-plaintext highlighter-rouge">Path</code> object로 실행 가능합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p</span> <span class="o">=</span> <span class="nc">Path</span><span class="p">(</span><span class="sh">"</span><span class="s">foo/bar</span><span class="sh">"</span><span class="p">)</span>
<span class="c1"># Rename foo/bar to baz (cannot overwrite directory)
</span><span class="n">p</span><span class="p">.</span><span class="nf">rename</span><span class="p">(</span><span class="sh">"</span><span class="s">baz</span><span class="sh">"</span><span class="p">)</span>
<span class="c1"># Force rename foo/bar to baz
</span><span class="n">p</span><span class="p">.</span><span class="nf">replace</span><span class="p">(</span><span class="sh">"</span><span class="s">baz</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># For files:
# Equivalent to rm foo/bar
</span><span class="n">p</span><span class="p">.</span><span class="nf">unlink</span><span class="p">()</span>
<span class="c1"># Equivalent to rm -f foo/bar; since 3.8 (Oct 2019)
</span><span class="n">p</span><span class="p">.</span><span class="nf">unlink</span><span class="p">(</span><span class="n">missing_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># For *empty* directories:
# Equivalent to rmdir foo/bar
</span><span class="n">p</span><span class="p">.</span><span class="nf">rmdir</span><span class="p">()</span>
</code></pre></div></div>

<p>이보다 복잡한 파일 및 디렉토리 복사/이동/삭제 작업은 <code class="language-plaintext highlighter-rouge">pathlib</code> 모듈만으로는 불가능합니다.</p>

<h2 id="high-level-file-operations">High-level file operations</h2>

<p>그래서 많은 사람들이 이런 코드를 사용합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">os</span>

<span class="n">os</span><span class="p">.</span><span class="nf">system</span><span class="p">(</span><span class="sh">"</span><span class="s">rm -rf foo/bar</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p>그러나 <code class="language-plaintext highlighter-rouge">os.system()</code> 함수는 되도록이면 사용을 지양하는 것이 좋습니다.</p>

<h3 id="whats-wrong-with-ossystem">What’s wrong with <code class="language-plaintext highlighter-rouge">os.system()</code>?</h3>

<p>가장 큰 문제는 별도의 보호장치가 없다는 것입니다. 예를 들어, 코딩 중에 다음과 같이 오타를 냈다고 생각해 봅시다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#                 ↓ Oops!
</span><span class="n">p</span> <span class="o">=</span> <span class="sh">"</span><span class="s">/home/jnooree /foo/bar</span><span class="sh">"</span>
<span class="n">os</span><span class="p">.</span><span class="nf">system</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">rm -rf </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p>축하합니다! 여러분의 <strong>홈 폴더가 통째로 사라졌군요</strong>. 이런 일이 실제로는 절대로 일어나지 않는다고 생각하신다면, 안타깝게도 틀렸습니다. 아주 유명한 사례로, Ubuntu에서 특정 오픈소스 패키지를 설치하면 설치 과정에서 <code class="language-plaintext highlighter-rouge">/usr</code> 디렉토리를 <del>친절하게도</del> <a href="https://github.com/MrMEEE/bumblebee-Old-and-abbandoned/issues/123">통째로 삭제해서 컴퓨터를 아주 깨끗하게 만들어 줬던 적이 있습니다</a><sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>. 해당 사례에서도 space 하나가 문제가 되었죠.</p>

<p>그래서 <code class="language-plaintext highlighter-rouge">os.system()</code>과 같이 주어진 문자열을 아무런 처리 없이 곧바로 실행하는 함수는 쓰지 않는 것이 좋습니다. 추가적인 논의는 이후 게시할 <code class="language-plaintext highlighter-rouge">subprocess</code> 모듈을 다루는 글에서 보실 수 있습니다.</p>

<h3 id="the-rescue-shutil">The rescue: <code class="language-plaintext highlighter-rouge">shutil</code></h3>

<p>저런 일 당하지 말라고 Python에는 <code class="language-plaintext highlighter-rouge">shutil</code> 모듈이 포함되어 있습니다. 앞서 언급했던 <code class="language-plaintext highlighter-rouge">pathlib</code> 모듈로는 불가능한 파일 및 디렉토리 복사/이동/삭제 작업에 특화되어 있는 모듈이죠.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">shutil</span>

<span class="c1"># Copy file data and permission
</span><span class="n">shutil</span><span class="p">.</span><span class="nf">copy</span><span class="p">(</span><span class="sh">"</span><span class="s">src.txt</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">dst.txt</span><span class="sh">"</span><span class="p">)</span>
<span class="c1"># Copy file dat and metadata (modified time, ...)
</span><span class="n">shutil</span><span class="p">.</span><span class="nf">copy2</span><span class="p">(</span><span class="sh">"</span><span class="s">src.txt</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">dst.txt</span><span class="sh">"</span><span class="p">)</span>
<span class="c1"># cp -a src dst, except raises error if dst exists
</span><span class="n">shutil</span><span class="p">.</span><span class="nf">copytree</span><span class="p">(</span><span class="sh">"</span><span class="s">src</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">dst</span><span class="sh">"</span><span class="p">)</span>
<span class="c1"># rsync -a src/ dst/; since 3.8 (Oct 2019)
</span><span class="n">shutil</span><span class="p">.</span><span class="nf">copytree</span><span class="p">(</span><span class="sh">"</span><span class="s">src</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">dst</span><span class="sh">"</span><span class="p">,</span> <span class="n">dirs_exist_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c1"># rm -r src
</span><span class="n">shutil</span><span class="p">.</span><span class="nf">rmtree</span><span class="p">(</span><span class="sh">"</span><span class="s">src</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="generate-temporary-files-and-directories">Generate temporary files and directories</h2>

<p>코딩을 하다 보면 가끔 임시로 사용하는 파일이나 디렉토리를 생성해야 하는 경우가 있습니다. 보통은 이런 방식을 사용하실 텐데요, 다른 사용자나 프로세스가 동일한 이름의 파일이나 디렉토리를 수정하려고 시도할 수 있기 때문에 권장하지 않습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Temporary file
</span><span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="sh">"</span><span class="s">temp.txt</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">w</span><span class="sh">"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span> <span class="bp">...</span>

<span class="c1"># Temporary directory
</span><span class="n">os</span><span class="p">.</span><span class="nf">mkdir</span><span class="p">(</span><span class="sh">"</span><span class="s">temp</span><span class="sh">"</span><span class="p">)</span>
<span class="bp">...</span>
<span class="n">os</span><span class="p">.</span><span class="nf">system</span><span class="p">(</span><span class="sh">"</span><span class="s">rm -rf temp</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p>대신 임시 파일 또는 디렉토리를 <strong>최대한 안전하게</strong> 생성해 주는 <code class="language-plaintext highlighter-rouge">tempfile</code> 모듈을 사용하세요.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">tempfile</span>

<span class="c1"># "Safe" way to write to a temporary file
</span><span class="k">with</span> <span class="n">tempfile</span><span class="p">.</span><span class="nc">TemporaryFile</span><span class="p">(</span><span class="sh">"</span><span class="s">w</span><span class="sh">"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span> <span class="bp">...</span>

<span class="c1"># If file name should be used afterwards, then
</span><span class="k">with</span> <span class="n">tempfile</span><span class="p">.</span><span class="nc">NamedTemporaryFile</span><span class="p">(</span><span class="sh">"</span><span class="s">w</span><span class="sh">"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="nf">foo</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">name</span><span class="p">)</span>
    <span class="bp">...</span>

<span class="c1"># For temporary directories; since 3.2 (Feb 2011)
</span><span class="k">with</span> <span class="n">tempfile</span><span class="p">.</span><span class="nc">TemporaryDirectory</span><span class="p">()</span> <span class="k">as</span> <span class="n">dirname</span><span class="p">:</span>
    <span class="bp">...</span>
</code></pre></div></div>

<p>해당 context를 벗어나면 자동으로 생성했던 임시 파일 또는 디렉토리(와 그 안에 있는 모든 것)를 삭제합니다.</p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Since Python 3.4 (Mar 2014) <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p><code class="language-plaintext highlighter-rouge">open()</code>뿐만 아니라, Python standard library에서 제공하는 대부분의 함수나 method에서 경로와 관련된 argument에는 <code class="language-plaintext highlighter-rouge">str</code> 타입과 <code class="language-plaintext highlighter-rouge">Path</code> 타입을 모두 사용할 수 있습니다. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>리눅스에서 <code class="language-plaintext highlighter-rouge">/usr</code> 디렉토리는 과장 좀 보태면 윈도의 <code class="language-plaintext highlighter-rouge">C</code> 드라이브와 비슷한 역할을 합니다. 전부 날려먹었으니 시스템이 통으로 망가지고 <del>가정이 무너지고 사회가 무너지고</del> 부팅이 안 되는건 당연하겠죠? <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Nuri Jung</name></author><category term="Exploring the Python Standard Library" /><category term="dev" /><category term="python" /><summary type="html"><![CDATA[Package index]]></summary></entry><entry><title type="html">More about built-ins</title><link href="https://blog.jnoor.ee/exploring%20the%20python%20standard%20library/2022/07/18/py-stdlib-builtins.html" rel="alternate" type="text/html" title="More about built-ins" /><published>2022-07-18T15:12:17+09:00</published><updated>2022-07-18T16:17:38+09:00</updated><id>https://blog.jnoor.ee/exploring%20the%20python%20standard%20library/2022/07/18/py-stdlib-builtins</id><content type="html" xml:base="https://blog.jnoor.ee/exploring%20the%20python%20standard%20library/2022/07/18/py-stdlib-builtins.html"><![CDATA[<h2 id="iterator-wrappers">Iterator wrappers</h2>

<p>기본 제공되는 유용한 iterator wrapper는 <code class="language-plaintext highlighter-rouge">enumerate</code>와 <code class="language-plaintext highlighter-rouge">zip</code>이 있습니다. 각각 iteration 과정에서 index가 value와 함께 필요한 경우,</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Don't:
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
    <span class="nf">foo</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

<span class="c1"># Do:
</span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="nf">foo</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</code></pre></div></div>

<p>그리고 여러 개의 iterable을 동시에 iteration하는 경우에 사용합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Don't:
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
    <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

<span class="c1"># Do:
</span><span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="nf">foo</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
</code></pre></div></div>

<p>둘 모두 <strong>하지 말라</strong>고 하는 공통적인 이유는 속도 차이가 상당히 많이 나기 때문입니다. 이에 대한 좀 더 자세한 논의는 바로 뒤에 이어서 다룹니다.</p>

<p>그러나 <code class="language-plaintext highlighter-rouge">zip</code>을 사용해야만 하는 더 큰 이유는 두 iterable의 <strong>길이가 다른 경우</strong> indexing을 하면 예기치 못한 <code class="language-plaintext highlighter-rouge">IndexError</code>가 발생할 수 있지만, <code class="language-plaintext highlighter-rouge">zip</code>은 둘 중 더 길이가 짧은 iterable의 길이까지만 사용하기 때문입니다. 속도 차이야 무시하고 쓰더라도, 에러가 발생하는 것은 최대한 방지해야 하겠죠.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>

<span class="c1"># IndexError
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
    <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

<span class="c1"># Supplies (1, 4) then (2, 5) (no IndexError)
</span><span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="nf">foo</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="benchmarks">Benchmarks</h3>

<p>Python은 indexing시 메모리에 직접 접근하여 비용이 거의 들지 않는 C 등의 언어와는 달리, indexing도 일종의 함수 호출 과정을 거치므로 상당한 비용을 지불합니다. 따라서 indexing의 속도가 매우 느립니다. 앞서 사용했던 코드의 시간을 실제로 측정해 보면 다음과 같습니다.</p>

<figure class="image">
	<img src="/assets/images/posts/exploring-python-stdlib/enumerate-bench.png" alt="Tested on M1 mac mini (2020), Python 3.10.5" /><figcaption>Tested on M1 mac mini (2020), Python 3.10.5</figcaption></figure>

<figure class="image">
	<img src="/assets/images/posts/exploring-python-stdlib/zip-bench.png" alt="Tested on M1 mac mini (2020), Python 3.10.5" /><figcaption>Tested on M1 mac mini (2020), Python 3.10.5</figcaption></figure>

<p>각각 10%, 20% 정도의 속도 차이가 있는데요, 따라서 indexing 한 번마다 대략 10% 정도의 속도 손해가 있다고 보셔도 무방하겠습니다.</p>

<h3 id="one-more-thing">One more thing</h3>

<p><code class="language-plaintext highlighter-rouge">enumerate</code>에는 많은 사람들이 모르고 있는 추가적인 keyword argument인 <code class="language-plaintext highlighter-rouge">start</code>가 있습니다. 듣자마자 예상하셨겠지만, 시작하는 index를 정해줄 수 있는 기능입니다. 그동안 <code class="language-plaintext highlighter-rouge">i + 1</code>을 쓰시던 분들은 이걸 들으면 뒤로 넘어가시겠군요.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Don't:
</span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="nf">foo</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

<span class="c1"># Do:
</span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="nf">foo</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</code></pre></div></div>

<p>역시 벤치마크가 빠지면 섭하죠? 이번에도 약간의 속도 차이가 있습니다.</p>

<figure class="image">
	<img src="/assets/images/posts/exploring-python-stdlib/enumerate-start-bench.png" alt="Tested on M1 mac mini (2020), Python 3.10.5" /><figcaption>Tested on M1 mac mini (2020), Python 3.10.5</figcaption></figure>

<p>이보다 복잡한 경우에는 <code class="language-plaintext highlighter-rouge">zip</code>과 조합하여 더 빠르게 실행할 수는 있지만, 대부분의 경우 코드의 가독성을 크게 낮추고 실수할 여지가 늘어나기 때문에 시도하지 않는 것이 좋습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Don't:
</span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">a</span><span class="p">):</span>
    <span class="nf">foo</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

<span class="c1"># Do:
</span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="nf">foo</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="boolean-evaluators">Boolean evaluators</h2>

<p>꽤 유용한 기능인데, 많이들 모르고 계시는 <code class="language-plaintext highlighter-rouge">any</code>와 <code class="language-plaintext highlighter-rouge">all</code> function에 대한 간략한 소개입니다. 다음 두 for문은 한 줄로 짧게 줄일 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># For loop
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">There is an odd number</span><span class="sh">"</span><span class="p">)</span>
        <span class="k">break</span>

<span class="c1"># any()
</span><span class="k">if</span> <span class="nf">any</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">a</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">There is an odd number</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># For loop
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">break</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">They are all odd numbers</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># all()
</span><span class="k">if</span> <span class="nf">all</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">a</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">They are all odd numbers</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p>간단한 for문은 이렇게 <code class="language-plaintext highlighter-rouge">any</code>나 <code class="language-plaintext highlighter-rouge">all</code>로 바꾸기만 해도 코드의 가독성이 크게 증가한다는 장점이 있습니다.</p>

<h2 id="iterating-dict">Iterating <code class="language-plaintext highlighter-rouge">dict</code></h2>

<p><code class="language-plaintext highlighter-rouge">dict</code> 타입은 아주 빠르고 유용하며, Python에서 <code class="language-plaintext highlighter-rouge">list</code>와 더불어 자주 사용됩니다. 그러나 <code class="language-plaintext highlighter-rouge">dict</code> 타입을 iteration할 때 많은 사람들이 key와 value를 동시에 얻지 않고, 추가적인 indexing 비용을 지불하는 방식으로 사용하는 실수를 저지릅니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Don't:
</span><span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
    <span class="nf">foo</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

<span class="c1"># Do:
</span><span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
    <span class="nf">foo</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</code></pre></div></div>

<p>두 방식의 속도 차이는 대략 20%가량 납니다<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.</p>

<figure class="image">
	<img src="/assets/images/posts/exploring-python-stdlib/dict-items-bench.png" alt="Tested on M1 mac mini (2020), Python 3.10.5" /><figcaption>Tested on M1 mac mini (2020), Python 3.10.5</figcaption></figure>

<h2 id="new-str-methods">New <code class="language-plaintext highlighter-rouge">str</code> methods</h2>

<p>Python 3.9<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>에 추가된 <code class="language-plaintext highlighter-rouge">str</code> 타입의 method는 다음과 같습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="sh">"</span><span class="s">This is a sample string</span><span class="sh">"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="p">.</span><span class="nf">removeprefix</span><span class="p">(</span><span class="sh">"</span><span class="s">This</span><span class="sh">"</span><span class="p">)</span>
<span class="sh">'</span><span class="s"> is a sample string</span><span class="sh">'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="p">.</span><span class="nf">removesuffix</span><span class="p">(</span><span class="sh">"</span><span class="s">ing</span><span class="sh">"</span><span class="p">)</span>
<span class="sh">'</span><span class="s">This is a sample str</span><span class="sh">'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="p">.</span><span class="nf">removeprefix</span><span class="p">(</span><span class="sh">"</span><span class="s">foo</span><span class="sh">"</span><span class="p">)</span>
<span class="sh">'</span><span class="s">This is a sample string</span><span class="sh">'</span>
</code></pre></div></div>

<p>해당 prefix나 suffix가 존재하지 않으면 원본을 그대로 반환하므로, 문자열 처리에 굉장히 유용하게 사용 가능합니다.</p>

<h2 id="wrap-up">Wrap-up</h2>

<p>이번 글에서는 Python의 built-in function과 type에 대해 간단히 살펴보았습니다. 더 많은 정보는 각각 <a href="https://docs.python.org/3/library/functions.html">여기</a>와 <a href="https://docs.python.org/3/library/stdtypes.html">여기</a>를 참고하시면 됩니다.</p>

<p>다음 글에서는 실제 코딩에서 아주 유용하게 사용되는 <strong>파일 및 경로 관련 library</strong>에 대해 알아보겠습니다.</p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>여기에서 소개하는 결과는 가장 자주 key로 사용되는 <code class="language-plaintext highlighter-rouge">str</code> 타입을 기준으로 한 결과입니다. Python의 <code class="language-plaintext highlighter-rouge">dict</code> 타입은 <a href="https://stackoverflow.com/a/9022835">hash table로 구현되어 있으므로</a>, 벤치마크 결과는 key의 hashing에 필요한 연산량에 따라 영향을 받습니다. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>Released on Oct 2021. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Nuri Jung</name></author><category term="Exploring the Python Standard Library" /><category term="dev" /><category term="python" /><summary type="html"><![CDATA[Iterator wrappers]]></summary></entry><entry><title type="html">Advanced Python Syntax</title><link href="https://blog.jnoor.ee/exploring%20the%20python%20standard%20library/2022/07/11/py-stdlib-syntax.html" rel="alternate" type="text/html" title="Advanced Python Syntax" /><published>2022-07-11T23:22:31+09:00</published><updated>2022-07-18T15:10:25+09:00</updated><id>https://blog.jnoor.ee/exploring%20the%20python%20standard%20library/2022/07/11/py-stdlib-syntax</id><content type="html" xml:base="https://blog.jnoor.ee/exploring%20the%20python%20standard%20library/2022/07/11/py-stdlib-syntax.html"><![CDATA[<h2 id="혹시-이거-아시나요">혹시 이거 아시나요?</h2>

<ul>
  <li><a href="#triple-quotes">Triple quotes</a> (“docstrings”)</li>
  <li><a href="#f-string"><em>f</em>-string</a> (formatted string literals)<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></li>
  <li><a href="#ternary-operator">Ternary operator</a></li>
  <li><a href="#or-as-a-conditional-statement"><code class="language-plaintext highlighter-rouge">or</code> as a conditional statement</a></li>
  <li><a href="#comprehensions">Comprehensions</a></li>
  <li><a href="#assignment-expression">Assignment expression</a><sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></li>
  <li><a href="#loop-else-construct">Loop-else construct</a></li>
</ul>

<h2 id="triple-quotes">Triple quotes</h2>

<p>이런 걸 어딘가에서 많이 보셨을 겁니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="sh">"""</span><span class="s">
    This is a docstring.
    </span><span class="sh">"""</span>
    <span class="k">pass</span>
</code></pre></div></div>

<p>C나 다른 언어를 하다 오신 분의 경우에는 그냥 함수를 설명하는 주석(block comment)이겠거니 하고 넘기셨을 수도 있습니다만, 사실 Python에서는 triple-quoted string 역시 일반적인 string literal과 동일하게 사용 가능합니다. 그런데 왜 굳이 귀찮게 세번씩 쳐야 하냐고요?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">long_string</span> <span class="o">=</span> <span class="sh">"</span><span class="s">A very long string with</span><span class="se">\n</span><span class="sh">"</span> \
    <span class="o">+</span> <span class="sh">"</span><span class="s">multiple lines</span><span class="se">\n</span><span class="sh">"</span> \
    <span class="o">+</span> <span class="sh">"</span><span class="s">and many words</span><span class="sh">"</span>
</code></pre></div></div>

<p>아마 그동안은 string literal 안에서 줄바꿈이 불가능하기 때문에 이렇게 쓰셨던 적이 많겠지만, 이렇게 작성하면 한눈에 잘 들어오지도 않을 뿐더러 속도도 느립니다. Triple-quoted string을 사용하면 다음과 같이 깔끔하게 표현이 가능합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">long_string</span> <span class="o">=</span> <span class="sh">"""</span><span class="s">A very long string with
multiple lines
and many words</span><span class="sh">"""</span>
</code></pre></div></div>

<p>그냥 줄바꿈을 하는 대로 곧바로 반영되기 때문이죠. 첫 줄이 나머지랑 정렬이 안 돼서 영 마음에 안 드신다고요? 백슬래시(<code class="language-plaintext highlighter-rouge">\</code>)를 찍어서 드셔보세요.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">long_string</span> <span class="o">=</span> <span class="sh">"""</span><span class="se">\
</span><span class="s">A very long string with
multiple lines
and many words</span><span class="sh">"""</span>
</code></pre></div></div>

<p>물론 안에서 추가 줄바꿈을 하면 그대로 반영됩니다. 앞에 띄어쓰기를 포함하면 그것도 함께 포함됩니다. 그러니까 다음 예제를 실행하면…</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">long_string</span> <span class="o">=</span> <span class="sh">"""</span><span class="se">\
</span><span class="s">
A very long string with
    multiple lines
    and many words</span><span class="sh">"""</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nf">print</span><span class="p">(</span><span class="n">long_string</span><span class="p">)</span>

<span class="n">A</span> <span class="n">very</span> <span class="nb">long</span> <span class="n">string</span> <span class="k">with</span>
    <span class="n">multiple</span> <span class="n">lines</span>
    <span class="ow">and</span> <span class="n">many</span> <span class="n">words</span>
</code></pre></div></div>

<p>이런 식이 되는 셈이죠. 보통은 여러 출력에서 template string으로 많이 사용됩니다.</p>

<h2 id="f-string"><em>f</em>-string</h2>

<p>프로그래밍에서 절대로 빼놓을 수 없는 편의기능을 한 개만 고르라면, string formatting을 고르는 사람도 꽤 있을 겁니다. Python은 전통적으로 C와 비슷한 <code class="language-plaintext highlighter-rouge">%</code>-formatting을 지원하지만, 이 방식은 1) <strong>포맷할 자리와 값을 두 차례 전달하기 때문에 실수할 여지가 많다는 문제가 있고</strong>, 2) 속도가 느립니다<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>. 이후 등장한 string type의 <code class="language-plaintext highlighter-rouge">.format()</code> 메서드 역시 비슷한 문제를 공유합니다.</p>

<p>Python 3.6 버전에서 추가된 <em>f</em>-string<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup>을 사용하면 이런 문제를 깔끔하게 회피 가능합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">name</span> <span class="o">=</span> <span class="sh">"</span><span class="s">Nuri Jung</span><span class="sh">"</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">My name is </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p>말 그대로 literal이기 때문에 lazy evaluation<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup>이 일어나지 않습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">name</span> <span class="o">=</span> <span class="sh">"</span><span class="s">Nuri Jung</span><span class="sh">"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">intro</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">"</span><span class="s">My name is </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="sh">"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">name</span> <span class="o">=</span> <span class="sh">"</span><span class="s">John Doe</span><span class="sh">"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nf">print</span><span class="p">(</span><span class="n">intro</span><span class="p">)</span>
<span class="n">My</span> <span class="n">name</span> <span class="ow">is</span> <span class="n">Nuri</span> <span class="n">Jung</span>
</code></pre></div></div>

<p>기존에 되던 것들은 전부 됩니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">The result is </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
<span class="n">The</span> <span class="n">result</span> <span class="ow">is</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">%f</code> formatting이 그리우신 분들을 위한 실수 포맷팅도 당연히 지원합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">/</span> <span class="mi">3</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">The result is </span><span class="si">{</span><span class="n">num</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
<span class="n">The</span> <span class="n">number</span> <span class="ow">is</span> <span class="mf">33.33333333333336</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">The result is </span><span class="si">{</span><span class="n">num</span><span class="si">:</span><span class="p">.</span><span class="mi">3</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>  <span class="c1"># 유효숫자 기준입니다
</span><span class="n">The</span> <span class="n">number</span> <span class="ow">is</span> <span class="mf">33.3</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">The result is </span><span class="si">{</span><span class="n">num</span><span class="si">:</span><span class="mf">5.3</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
<span class="n">The</span> <span class="n">number</span> <span class="ow">is</span>  <span class="mf">33.3</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">The result is </span><span class="si">{</span><span class="n">num</span><span class="si">:</span><span class="mf">05.3</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
<span class="n">The</span> <span class="n">number</span> <span class="ow">is</span> <span class="mf">033.3</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">The result is </span><span class="si">{</span><span class="n">num</span><span class="si">:</span><span class="mf">03.3</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>  <span class="c1"># 칸수는 "최소"입니다
</span><span class="n">The</span> <span class="n">number</span> <span class="ow">is</span> <span class="mf">33.3</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">The result is </span><span class="si">{</span><span class="n">num</span><span class="si">:</span><span class="p">.</span><span class="mi">3</span><span class="n">f</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>  <span class="c1"># f는 소수점 이하 자리수 기준입니다
</span><span class="n">The</span> <span class="n">number</span> <span class="ow">is</span> <span class="mf">33.333</span>
</code></pre></div></div>

<h3 id="one-more-thing">One more thing…</h3>

<p>최근<sup id="fnref:2:1" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>에는 더 좋아져서 이런 것도 지원합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">num</span> <span class="o">=</span> <span class="si">:</span><span class="p">.</span><span class="mi">3</span><span class="n">f</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
<span class="n">num</span> <span class="o">=</span> <span class="mf">33.333</span>
</code></pre></div></div>

<h3 id="benchmarks">Benchmarks</h3>

<p>아까 제가 느리다고 했는데, 얼마나 느린지 궁금하신 여러분들을 위해 벤치마크도 준비했습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># f-string
</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="sh">"</span>
<span class="c1"># string format
</span><span class="sh">"</span><span class="s">{} {}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
<span class="c1"># percent format
</span><span class="sh">"</span><span class="s">%s %s</span><span class="sh">"</span> <span class="o">%</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

<span class="c1"># plus operator
</span><span class="n">s</span> <span class="o">+</span> <span class="sh">"</span><span class="s"> </span><span class="sh">"</span> <span class="o">+</span> <span class="n">t</span>
<span class="c1"># string join
</span><span class="sh">"</span><span class="s"> </span><span class="sh">"</span><span class="p">.</span><span class="nf">join</span><span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
</code></pre></div></div>

<figure class="image">
	<img src="/assets/images/posts/exploring-python-stdlib/fstring-bench.png" alt="Tested on M1 mac mini (2020), Python 3.10.5" /><figcaption>Tested on M1 mac mini (2020), Python 3.10.5</figcaption></figure>

<p>심하게는 두배 이상도 차이나네요? 물론 plus operator와 string join은 원래 formatting 용도로 만든게 아니니 공정한 비교는 아닙니다만, 그래도 궁금하실 여러분을 위해 넣어봤습니다.</p>

<h3 id="실제-사용례">실제 사용례</h3>

<p>연구실 슬랙 봇 코드 중 일부를 가져왔습니다. 보시는 것처럼 template을 만들 때 triple-quoted string과 조합하면 유용하게 쓸 수 있습니다.</p>

<figure class="image">
	<img src="/assets/images/posts/exploring-python-stdlib/fstring-usage.png" alt="" /><figcaption>From the galaxybot <a href="https://github.com/seoklab/galaxybot/blob/205ef5fe5b7f57cb896b920829dded02a9bfeda4/galaxybot/automations/meeting.py#L210-L226">source code</a></figcaption></figure>

<h2 id="ternary-operator">Ternary operator</h2>

<p>다른 언어에 익숙한 분들은 Python을 처음 쓸 때 <code class="language-plaintext highlighter-rouge">?:</code> 연산자를 시도하고 장렬하게 <code class="language-plaintext highlighter-rouge">SyntaxError</code>와 함꼐 산화한 경험이 있으실 겁니다. 그렇다고 Python에 ternary operator가 없는 것은 아닙니다.</p>

<p>Ternary operator는 기본적으로는 다음과 같은 작업을 줄여서 쓰기 위해 도입되었습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">a</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="p">)</span>
</code></pre></div></div>

<p>딱 봐도 뭔가 반복이 많고, 단순한 작업인데도 네 줄이나 차지하네요. 이를 한 줄로 줄이기 위한 편리한 operator가 바로 ternary operator입니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">print</span><span class="p">(</span><span class="n">a</span> <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="n">a</span><span class="p">)</span>
</code></pre></div></div>

<p>항상 그렇듯이 Python 특유의 <del>변태적인</del> 문법이 눈에 띄는군요. 영어를 잘 하는 분이라면 그래도 좀더 직관적으로 와닿을지도 모르겠습니다. 영어 어순과 거의 동일하게 논리가 흘러가기 때문이죠<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">6</a></sup>.</p>

<p>좀 더 formal하게 정의하면, 다음 두 식의 실행 결과 <code class="language-plaintext highlighter-rouge">result</code>는 같습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># By conditional statement
</span><span class="nf">if </span><span class="p">(</span><span class="n">expression</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">if_true</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">if_false</span><span class="p">)</span>

<span class="c1"># By ternary operator
</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">if_true</span><span class="p">)</span> <span class="nf">if </span><span class="p">(</span><span class="n">expression</span><span class="p">)</span> <span class="nf">else </span><span class="p">(</span><span class="n">if_false</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="or-as-a-conditional-statement"><code class="language-plaintext highlighter-rouge">or</code> as a conditional statement</h2>

<p>이번에 보여드릴 것은 ternary operator랑 비슷하게 사용 가능한 기법입니다. 코딩하다 보면 다음과 같은 방식으로 처리해야 하는 경우가 꽤 많습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">a</span><span class="p">:</span>
    <span class="n">foo</span> <span class="o">=</span> <span class="n">a</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">foo</span> <span class="o">=</span> <span class="n">b</span>
</code></pre></div></div>

<p>물론 방금 나온 ternary operator를 사용하면 좀 더 줄일 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">foo</span> <span class="o">=</span> <span class="n">a</span> <span class="k">if</span> <span class="n">a</span> <span class="k">else</span> <span class="n">b</span>
</code></pre></div></div>

<p>하지만 정말 간단하게 처리하는 방법이 있는데, 바로 <code class="language-plaintext highlighter-rouge">or</code> operator를 응용하는 것입니다. 이는 <code class="language-plaintext highlighter-rouge">or</code> operator가 첫 번째 operand가 참인 경우 그 결과를 그대로 반환하고, 거짓인 경우 두 번째 operand를 그대로 반환하기 때문에 가능한 트릭입니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">foo</span> <span class="o">=</span> <span class="n">a</span> <span class="ow">or</span> <span class="n">b</span>
</code></pre></div></div>

<h3 id="실제-사용례-1">실제 사용례</h3>

<p>연구실 코드에도 이와 같은 처리가 포함된 부분이 있습니다.</p>

<figure class="image">
	<img src="/assets/images/posts/exploring-python-stdlib/or-conditional-usage.png" alt="" /><figcaption>From the GalaxyPipe <a href="https://github.com/seoklab/GalaxyPipe/blob/1a696852206703c43181761a085c3f5e02673774/lib/Galaxy/config.py#L23-L24">source code</a></figcaption></figure>

<h2 id="comprehensions">Comprehensions</h2>

<p>List comprehension 자체는 나름대로 유명하고 많이들 사용하는 편입니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># For loop
</span><span class="n">squares</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">squares</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># List comprehension
</span><span class="n">squares</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
</code></pre></div></div>

<p>그런데 전체 iterable에 대해 처리하는 경우가 아니라, 그 중 일부만을 처리하고 싶은 경우라면 어떻게 해야 하는지 막막하신 분들이 많습니다. 이럴 경우 <code class="language-plaintext highlighter-rouge">if</code>문을 맨 뒤에 붙여주면 됩니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># For loop
</span><span class="n">squares</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">squares</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># List comprehension
</span><span class="n">squares</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span><span class="p">]</span>
</code></pre></div></div>

<p>둘 모두를 경우에 따라 처리해야 한다면 앞에서 나왔던 ternary operator를 이용하면 됩니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># For loop
</span><span class="n">squares</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">squares</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">squares</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># List comprehension
</span><span class="n">squares</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="k">else</span> <span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
</code></pre></div></div>

<p>당연히 list comprehension 뿐만 아니라 set comprehension, dictionary comprehension 등도 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># For loop
</span><span class="n">squares</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">squares</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Set comprehension
</span><span class="n">squares</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span><span class="p">}</span>
<span class="c1"># Dictionary comprehension
</span><span class="n">squares</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span><span class="p">}</span>

<span class="c1"># Tuple comprehension?
</span><span class="n">squares</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>그러나 마지막과 같이 쓰면 tuple comprehension이 아니라 <a href="https://docs.python.org/3/reference/expressions.html#generator-expressions">generator expression</a><sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup>이 됩니다. Tuple로 바꾸고 싶은 경우 tuple로 type casting해 줍시다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">squares</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="assignment-expression">Assignment expression</h2>

<p>Python에서 assignment문은 다른 많은 언어에서와는 달리 <strong>expression이 아닙니다</strong><sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">8</a></sup>. 즉, assignment문은 아무것도 반환하지 않습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># SyntaxError
</span><span class="k">if</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">a is 1</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p>하지만 대입과 동시에 조건을 확인하는 코드는 (다소 가독성이 떨어지는 문제가 생기는 경우도 있지만) 대부분의 while loop에서 상당히 유용하게 사용됩니다. 예를 들어 다음과 같은 코드는 만약 assignment문이 expression이었다면 가독성의 저하 없이도 덜 장황하게 짤 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Without assignment expression
</span><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="nf">foo</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">flag</span>
        <span class="k">break</span>
    <span class="nf">do_something</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>

<span class="c1"># If assignment statement were expression...
</span><span class="k">while</span> <span class="n">flag</span> <span class="o">=</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="nf">do_something</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>
</code></pre></div></div>

<p>그래서 Python 3.8에서는 assignment expression을 위한 Walrus operator(<code class="language-plaintext highlighter-rouge">:=</code>)를 도입합니다. 따라서 이제는 이렇게 사용이 가능합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">while </span><span class="p">(</span><span class="n">flag</span> <span class="p">:</span><span class="o">=</span> <span class="nf">foo</span><span class="p">()):</span>
    <span class="nf">do_something</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>
</code></pre></div></div>

<p>여기에서 괄호는 반드시 필요합니다. 괄호가 없는 경우 <code class="language-plaintext highlighter-rouge">SyntaxError</code>가 발생합니다.</p>

<h3 id="실제-사용례-2">실제 사용례</h3>

<p>이번에도 연구실 슬랙 봇 코드를 가져왔습니다.</p>

<figure class="image">
	<img src="/assets/images/posts/exploring-python-stdlib/assignment-expression-usage.png" alt="" /><figcaption>From the galaxybot <a href="https://github.com/seoklab/galaxybot/blob/205ef5fe5b7f57cb896b920829dded02a9bfeda4/galaxybot/commands/meeting.py#L160-L167">source code</a></figcaption></figure>

<h2 id="loop-else-construct">Loop-else construct</h2>

<p>많은 사람들의 인식과는 달리 Python은 있어야 할 것은 없고 없어도 되는 것은 있는 경우가 꽤 잦은, 독특한 언어입니다. Loop-else construct도 “없어도 되는” syntax의 예시인데요, 물론 꽤나 유용하게 사용되기는 하지만 이런 문법은 다른 언어에서는 찾아보기 어렵습니다.<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">9</a></sup></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># For-else statement
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">42</span><span class="p">:</span>
        <span class="k">break</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">No answer</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># ...which is equivalent to:
</span><span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">42</span><span class="p">:</span>
        <span class="n">found</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">break</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">No answer</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p>즉, loop의 정상적인 종료 시에만 (<code class="language-plaintext highlighter-rouge">break</code>이나 <code class="language-plaintext highlighter-rouge">return</code>등을 통해 loop이 끝나지 않는 경우에만) else문이 실행됩니다. Loop을 돌면서 특정 조건을 만족하는지 확인하고, 만족하지 않는 경우 예외 처리를 해야 하는 코드에서 유용하게 사용됩니다. 예시로는 for문만 들었지만, loop else construct라는 말에서도 볼 수 있듯이 while loop도 else문의 사용이 가능합니다.</p>

<h2 id="wrap-up">Wrap-up</h2>

<p><strong>모를 법</strong>한 Python syntax를 살펴봤습니다. 다음 포스트에서는 유용한 built-in에 대해 살펴보겠습니다. 원래는 하나의 글로 기획했는데 생각보다 길어져서 분리하게 되었네요.</p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Since Python 3.6 (Dec 2016) <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>Since Python 3.8 (Oct 2019) <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:2:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>실수할 여지가 많다는 것이 더 큰 문제입니다. 어차피 둘 모두 충분히 빠르기 때문에 속도 이슈는 대부분의 경우 코드 실행 시간에 별다른 영향을 미치지 않습니다 (<a href="https://en.wikipedia.org/wiki/Amdahl%27s_law">Amdahl’s law</a>). <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>String literal 앞에 <code class="language-plaintext highlighter-rouge">f</code> 표기를 붙이기 때문에 <em>f</em>-string이라고 불립니다. 정식 명칭은 <a href="https://docs.python.org/3/tutorial/inputoutput.html#tut-f-strings">formatted string literal</a>입니다. 더 자세한 명세는 <a href="https://docs.python.org/3/reference/lexical_analysis.html#f-strings">이쪽</a>을 참고하세요. <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>어떤 식의 값이 정의 시점이 아니라 사용 시점에 결정되는 것을 말합니다. 대표적인 lazy evaluation의 예시에는 <code class="language-plaintext highlighter-rouge">range()</code>가 있습니다. <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>그렇다고 평가 순서까지 직관적인 것은 아닙니다. 조건문이 가장 먼저 실행되고, 조건문이 참이면 if 이전의 코드가, 거짓이면 else 이후의 코드가 실행됩니다. <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>Lazy evaluation을 지원하는 iterator. 실제로 iteration을 할 때 (eg. for loop) 각각의 값이 계산된다. <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p><a href="https://docs.python.org/3/glossary.html#term-expression">여기</a>를 참고하세요. <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:9" role="doc-endnote">
      <p>이 syntax가 어쩌다 도입되었는지가 궁금하다면, 이 <a href="https://stackoverflow.com/a/23748240">stackoverflow 답변</a>을 참고하세요. <a href="#fnref:9" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Nuri Jung</name></author><category term="Exploring the Python Standard Library" /><category term="dev" /><category term="python" /><summary type="html"><![CDATA[혹시 이거 아시나요?]]></summary></entry><entry><title type="html">Exploring the Python Standard Library</title><link href="https://blog.jnoor.ee/exploring%20the%20python%20standard%20library/2022/07/09/exploring-py-stdlib-intro.html" rel="alternate" type="text/html" title="Exploring the Python Standard Library" /><published>2022-07-09T23:51:56+09:00</published><updated>2022-07-18T16:37:58+09:00</updated><id>https://blog.jnoor.ee/exploring%20the%20python%20standard%20library/2022/07/09/exploring-py-stdlib-intro</id><content type="html" xml:base="https://blog.jnoor.ee/exploring%20the%20python%20standard%20library/2022/07/09/exploring-py-stdlib-intro.html"><![CDATA[<blockquote>
  <p>“The standard library saves programmers from having to reinvent the wheel.”<br />
― Bjarne Stroustrup, father of the C++ programming language</p>
</blockquote>

<h2 id="preface">Preface</h2>

<p>초보 개발자들이 저지르기 가장 쉬운 실수는 바로 <strong>내가 필요로 하는 기능이 이미 구현되어 있는지 모르는 것</strong>이다. 개발을 하면서 경험이 쌓이면 “어 이거 어디서 봤던 것 같은데” 라든가, “이건 누가 만들어뒀을 법 한데” 같은 감이 생기지만, 처음부터 이런 관심법을 쓰기는 쉽지 않기 때문이다.</p>

<p>이 시리즈를 만들게 된 계기도 비슷한 <em>실수</em>를 연구실에서 많이 접했기 때문이다. Python의 모든 라이브러리를 다루는 것은 불가능하므로, 이 시리즈에서는 Python을 깔자마자 사용 가능한 Python stdandard library의 유용한 모듈을 둘러보도록 하겠다. 앞으로 총 6개의 글이 계획되어 있으며, 각각 다음과 같은 내용을 다룬다.</p>

<ol>
  <li>Advanced Python syntax</li>
  <li>More about built-ins</li>
  <li>Path manipulation</li>
  <li><code class="language-plaintext highlighter-rouge">collections</code> (containers)</li>
  <li>Subprocess management</li>
  <li>Miscellaneous useful modules</li>
</ol>

<h2 id="benchmark-code">Benchmark code</h2>

<p>이 시리즈는 여러 벤치마크를 포함한다. 벤치마크에서 실제로 실행한 코드는 <a href="https://gist.github.com/jnooree/57b70ac3c5e23260301538958ecfca13">Github Gist</a>에서 볼 수 있다.</p>

<h2 id="notes">Notes</h2>

<p>이 시리즈는 2022년 7월 8일 <a href="https://seoklab.org">연구실</a>에서 진행했던 동 제목의 <a href="https://drive.google.com/drive/folders/18SDWiRlrd2Ya47MItXZEs2JRZbFjvblr?usp=sharing">온라인 세미나</a>의 내용을 기반으로 한다.</p>]]></content><author><name>Nuri Jung</name></author><category term="Exploring the Python Standard Library" /><category term="dev" /><category term="python" /><summary type="html"><![CDATA[“The standard library saves programmers from having to reinvent the wheel.” ― Bjarne Stroustrup, father of the C++ programming language]]></summary></entry><entry><title type="html">도메인 샀습니다</title><link href="https://blog.jnoor.ee/general/2022/01/03/my-domain.html" rel="alternate" type="text/html" title="도메인 샀습니다" /><published>2022-01-03T22:07:44+09:00</published><updated>2022-01-03T23:19:03+09:00</updated><id>https://blog.jnoor.ee/general/2022/01/03/my-domain</id><content type="html" xml:base="https://blog.jnoor.ee/general/2022/01/03/my-domain.html"><![CDATA[<h2 id="네-질렀습니다">네, 질렀습니다</h2>

<p>오늘 <a href="https://galaxy.seoklab.org"><code class="language-plaintext highlighter-rouge">galaxy.seoklab.org</code></a>에 ssl 인증서를 설치하는
작업을 하면서 도메인이랑 DNS를 만져봤습니다. 그랬더니 문득 제 아이디인 <code class="language-plaintext highlighter-rouge">jnoor.ee</code>
도메인이 주인이 있는지 궁금해졌습니다. 찾아봤더니 주인이 없더군요.</p>

<figure class="image">
	<img src="/assets/images/posts/2022-01-03-my-domain/my-domain.png" alt="네, 질렀습니다." /><figcaption>네, 질렀습니다.</figcaption></figure>

<p>그래서 못 참고 질렀습니다. 1년에 세금 20% 포함해서 9.6 유로<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>에. 다행히 생각보다는 안 비싸서 부담없이 질렀군요. <a href="https://almic.ee"><code class="language-plaintext highlighter-rouge">almic</code></a>이라는 데서 구매했는데, 혹시 <code class="language-plaintext highlighter-rouge">ee</code> 도메인 필요하신 분 있으면 참고하세요<del>(?)</del> 제가 대충 찾아본 사이트중에는 제일 싼 것 같더라구요.</p>

<h2 id="근데-ee가-뭐냐-도대체">근데 ee가 뭐냐 도대체</h2>

<p>에스토니아의 <a href="https://en.wikipedia.org/wiki/Country_code_top-level_domain">ccTLD</a>입니다. ccTLD란 country code top-level domain의 준말로, 간단하게 설명하면 각 나라의 이름을 본따서 가져온, url에서 쓸 수 있는 최상위 레벨 구분자입니다. 우리나라에는 <code class="language-plaintext highlighter-rouge">kr</code>이 할당되어 있구요. 예전에는 <code class="language-plaintext highlighter-rouge">.com</code>, <code class="language-plaintext highlighter-rouge">.org</code> 등이 많이 사용되었지만 웹사이트가 너무 많아져서 추가되었습니다. <a href="https://zoom.us"><code class="language-plaintext highlighter-rouge">zoom.us</code></a>, <a href="https://youtu.be"><code class="language-plaintext highlighter-rouge">youtu.be</code></a>, <a href="https://twitch.tv"><code class="language-plaintext highlighter-rouge">twitch.tv</code></a> 등으로 쓰이는 신기한 도메인들도 다 이걸 응용 <del>악용</del> 해서 만드는 겁니다. 참고로 <code class="language-plaintext highlighter-rouge">be</code>는 벨기에의, <code class="language-plaintext highlighter-rouge">tv</code>는 무려 <strong>투발루</strong>의 ccTLD입니다. 우리나라도 재밌는 이름을 받았으면 많이 팔렸을 텐데 좀 아쉽네요.</p>

<h2 id="그럼-dns는">그럼 DNS<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>는?</h2>

<p>원래는 <code class="language-plaintext highlighter-rouge">almic</code> 회사에서 해주는 줄 알았는데 정확하게 잘 모르겠네요. 사이트를 이리저리 뒤져봐도 잘 안 보여서… 혹시 저기에서 사보신 분은 쓰는 법 알려주시면 감사하겠습니다. 도메인 사고 DNS까지 살 돈은 없어서 무료 DNS서비스 중 꽤 오래된 곳인 <a href="https://freedns.afraid.org"><code class="language-plaintext highlighter-rouge">freedns</code></a>에 등록했습니다. 블로그 호스팅 주소도 바꾸고 나니 뭔가 해낸 것만 같은 기분이 드는군요.</p>

<p>서브도메인 <code class="language-plaintext highlighter-rouge">blog.jnoor.ee</code>는 그래서 여기로 연결됩니다. <code class="language-plaintext highlighter-rouge">jnoor.ee</code> 도메인은 아직 개인 서버가 없어서 어디로 연결시킬까 고민중인데, 아마 대학원 입학해서 컴퓨터가 생기면 그쪽에 등록해 두면 되지 않을까 싶기는 합니다. 좋은 아이디어 있으시면 알려주세요!</p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>2022년 1월 기준 약 13,000원. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>Domain name system의 준말. <code class="language-plaintext highlighter-rouge">blog.jnoor.ee</code> 같은 도메인 이름을 서버의 실제 ip 주소로 바꾸어 주는 역할을 한다. 도메인 이름 - ip 주소는 대략 주소-우편번호의 관계와 비슷하다. 자세한 건 <a href="https://en.wikipedia.org/wiki/Domain_Name_System">이쪽으로</a>. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Nuri Jung</name></author><category term="general" /><category term="dev" /><category term="web" /><summary type="html"><![CDATA[네, 질렀습니다]]></summary></entry><entry><title type="html">개발 블로그 시작했습니다</title><link href="https://blog.jnoor.ee/general/2022/01/01/initial-post.html" rel="alternate" type="text/html" title="개발 블로그 시작했습니다" /><published>2022-01-01T23:00:00+09:00</published><updated>2022-01-02T17:22:14+09:00</updated><id>https://blog.jnoor.ee/general/2022/01/01/initial-post</id><content type="html" xml:base="https://blog.jnoor.ee/general/2022/01/01/initial-post.html"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>대학원 입학을 기념해서, 올해부터 개발 블로그를 시작하려 한다. 예전부터 블로그
쓰시는 개발자 분들을 종종 봐서 나도 해볼까 하다가 귀찮아서 매번 그만뒀는데,
새해라는 좋은 핑계도 있겠다, 이제는 슬슬 진짜 시작하면 좋을 것 같아서 정말로
블로그를 파게 됐다.</p>

<h2 id="왜-하필-githubio">왜 하필 github.io?</h2>

<p>그러게 말이다. 왜 그랬을까? 여러 블로그 서비스가 많은데… 제일 큰 이유는 역시
문서작업을 하면서 <a href="https://code.visualstudio.com">vscode</a>가 여러모로 꽤 편하다는
걸 깨달았기 때문이다. 반대급부로 <a href="https://jekyllrb.com">Jekyll</a> 설정을
수작업으로 전부 진행할 수밖에 없었다는 엄청난 단점이 기다리고 있었다. 웹 개발을 한번도
안 해본 나로서는 굉장한 모험이었다. 일단은 대충 정리되었으니 공개를 할 수 있었던
거긴 하지만서도.</p>

<h2 id="그래서-뭘-쓰려고">그래서 뭘 쓰려고?</h2>

<p>아직은 미정이다. 대부분은 journal review나 개발 관련 공부 내용이 되지 않을까
싶기는 한데, 쓰다 보면 좀 감이 잡히리라 생각한다. 시간상 첫 번째 포스팅은 아마
작년(이라고 해봐야 하루 전이긴 하지만)의 연말정산 글로 예정중이다. 페이스북에
올리긴 했지만 요즘엔 사람들이 페이스북을 하도 안 봐서 재탕해도 괜찮을 듯 하다.</p>]]></content><author><name>Nuri Jung</name></author><category term="general" /><category term="general" /><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">2021 연말정산</title><link href="https://blog.jnoor.ee/%EC%97%B0%EB%A7%90%EC%A0%95%EC%82%B0/2021/12/31/year-end-settlement.html" rel="alternate" type="text/html" title="2021 연말정산" /><published>2021-12-31T23:44:00+09:00</published><updated>2022-01-02T06:48:26+09:00</updated><id>https://blog.jnoor.ee/%EC%97%B0%EB%A7%90%EC%A0%95%EC%82%B0/2021/12/31/year-end-settlement</id><content type="html" xml:base="https://blog.jnoor.ee/%EC%97%B0%EB%A7%90%EC%A0%95%EC%82%B0/2021/12/31/year-end-settlement.html"><![CDATA[<p>12월 31일과 1월 1일 사이의 경계는 아무런 때도 아니다.</p>

<p>누군가는 지구가 동일한 위치를 지나는 날이라고 주장할지도 모르겠지만, 실제로는
그렇지 않다. 멀리 갈 필요 없이 지구의 공전 주기는 정확히 365일이 아니다. 어쩌면
1년이 365일에 꽤나 가까운 것도 기적에 가까울 지 모른다. 공전 주기가 꼭 자전
주기의 정확한 배수이어야만 하는 이유는 어디에도 없는 까닭에서다.</p>

<p>그럼에도 우리 모두는 연말이 되면 들뜨고, 새해를 맞이할 준비를 한다. 인간에게는
무언가 이정표가 필요한 법이다. “해”가 그러하고, “달”이 그러하고, “일”이
그러하다. 세 가지가 모두 바뀌는 1월 1일 0시는 (혹은 12월 31일 24시는) 그래서
우리에게는 중요한 때다. 올해를 마지막으로 20대의 절반을 마무리하며, 또한 대학을
졸업하게 되는 내게는 더더욱 그렇다.</p>

<p>돌이켜 보면 20대는 온통 서투름뿐이었다. 그러니 이제는 조금이나마 능숙한 어른이
되었으면 한다. 어른이 된다는 것이 무엇인지는 아직도 잘 모르겠지만서도. 알량한
대학 졸업장 하나로 어른이라 감히 말하기에, 세상은 너무 복잡하고 어렵다.
이해하려는 시도조차도 주제넘는 짓일 정도로.</p>

<p>대학원 진학을 결심한 것도 같은 맥락에서다. 이대로 세상에 던져지기에 나는 너무
어설프다. 혹자는 도피라고 폄하할지도 모른다. 부정할 생각은 없다. 나는 이렇게 몇
년의 유예를 얻은 셈이니. 언젠가는 깨어질 알 껍데기의 수명을 연장하는 게 내게는
최선이었다. 연구가 재미있고, 연구실 사람들이 좋고, 교수가 하고 싶고, 이런
이유들은 당연히 내 결심에 영향을 주기는 했지만, 결정적인 이유는 아니었다.
벌써부터 돈을 좇다간 어른이 되지 못할 것 같았다. 아직 내게는 시간이 더 필요하다.
세상을 보는 눈을 기를 시간이, 그리고 한 명의 사람으로 제구실을 할 수 있기까지의
시간이.</p>

<p>지난 6년간 옆에 있어주었던 사람과의 결혼도, 아직은 그래서 엄두를 내지 못한다.
언젠가 내가 한 명의 사람 몫을 충분히 할 수 있다는 확신이 생기면, 그때가 아마
네게 청혼하는 날이 되지 않을까. 내가 누군가와 새로운 가정을 온전히 꾸리기에
아직은 너무 이르다. 나는 어리고 부족하고, 내 자신조차 책임질 수 있다는 자신이
없으니. 완벽히 준비된 결혼은 없다지만 전혀 준비되지 않은 결혼도 없어야 한다고
생각한다.</p>

<p>뭐, 그렇다. 두서도 없고 별 의미도 없는 글 끝까지 읽어 주신 당신께 심심한 감사의
말씀을 올리며, 2021년 연말정산을 마친다. 내년에는 6년간 지겹도록 보았을 학부생
정누리 대신, 코딩하는 대학원생으로 다시 뵙도록 하겠다. 새해 복 많이 받으시길.</p>

<p>2021년의 마지막 밤,
스물다섯의 정누리 드림.</p>]]></content><author><name>Nuri Jung</name></author><category term="연말정산" /><category term="연말정산" /><summary type="html"><![CDATA[12월 31일과 1월 1일 사이의 경계는 아무런 때도 아니다.]]></summary></entry></feed>